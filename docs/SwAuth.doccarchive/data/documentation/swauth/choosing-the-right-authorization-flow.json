{"primaryContentSections":[{"kind":"content","content":[{"anchor":"AuthorizationCodeFlow","level":2,"type":"heading","text":"AuthorizationCodeFlow"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/AuthorizationCodeFlow"},{"type":"text","text":" is the most widely supported OAuth 2.0 flow since it is the basic OAuth 2.0 specification. It is used for devices that are not input-constrained (like on iOS, iPadOS, and macOS). However, it should be avoided if at all possible. As the warning I wrote in it‚Äôs respective documentation states, ‚ÄúThe OAuth 2.0 Authorization Code Flow is not secure for native applications, it should only be used when ABSOLUTELY NECESSARY.‚Äù The reason for this is that in a native app the client secret is included in the source, which you are compiling and distributing. Strings can be pretty easily extracted from compiled binaries, giving someone access to your client secret. Knowing the client secret would allow an attacker to exchange an intercepted authorization code for a token, giving the attacker access to your user‚Äôs account üò≥."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thus, if you are using SwAuth to send authorized requests to your server please implement "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc7636"},{"type":"text","text":". I‚Äôm sure there is a library or framework that implements it for whatever language you are using server-side ("},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/panva\/node-oidc-provider"},{"type":"text","text":"). If it is not your server, contact the owner and ask about implementing PKCE. If all else fails you may be forced to use the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/AuthorizationCodeFlow"},{"type":"text","text":", in which case I‚Äôd recommend using some sort of obfuscation and encryption technique for the client secret (at a minimum don‚Äôt just have a client secret as a plain string). Obfuscation isn‚Äôt very secure but it‚Äôs better than nothing."}]},{"anchor":"PKCEAuthorizationFlow","level":2,"type":"heading","text":"PKCEAuthorizationFlow"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Much like the AuthorizationCodeFlow, the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/PKCEAuthorizationFlow"},{"type":"text","text":" is used for devices that are not input-constrained (like iOS, iPadOS, and macOS). Unlike the AuthorizationCodeFlow, the PKCE Authorization Code Flow is safe for use in native applications (the spec was created for such purpose). No need to provide the client secret, with PKCE (Proof Key for Code Exchange) an attacker in possession of an intercepted Authorization Code can‚Äôt exchange it for a token unless they have the on-device-cryptographically-generated code verifier."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The downside is that the Proof Key for Code Exchange extension to the OAuth 2.0 Authorization Code Grant needs to be supported by the Web API you are trying to send requests to. If you own the server, great! implement "},{"overridingTitleInlineContent":[{"type":"text","text":"RFC 7636"}],"isActive":true,"type":"reference","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc7636","overridingTitle":"RFC 7636"},{"type":"text","text":" and\/or find a server-side framework or library that implements it ("},{"overridingTitleInlineContent":[{"type":"text","text":"again, here‚Äôs one for Node.js"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/panva\/node-oidc-provider","overridingTitle":"again, here‚Äôs one for Node.js"},{"type":"text","text":"). Otherwise, ask the owner to implement it."}]},{"anchor":"DeviceAuthorizationFlow","level":2,"type":"heading","text":"DeviceAuthorizationFlow"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/DeviceAuthorizationFlow"},{"type":"text","text":" is used for use on devices that are input-constrained (like watchOS and tvOS). If the Web API you are trying to send requests to does not support the  Device Authorization Grant ask the owner. If you own the server implement it or use a server-side library\/framework that supports it."}]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swauth\/choosing-the-right-authorization-flow"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwAuth\/documentation\/SwAuth\/Choosing-the-right-Authorization-Flow","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"SwAuth provides 3 different OAuth 2.0 authorization flows to use: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/AuthorizationCodeFlow"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/PKCEAuthorizationFlow"},{"type":"text","text":", and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/DeviceAuthorizationFlow"},{"type":"text","text":". Choosing which one to use and in what context can be difficult."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Choosing the Right Authorization Flow","role":"article","modules":[{"name":"SwAuth"}]},"hierarchy":{"paths":[["doc:\/\/SwAuth\/documentation\/SwAuth"]]},"seeAlsoSections":[{"title":"Essential","identifiers":["doc:\/\/SwAuth\/documentation\/SwAuth\/Swauthable"],"generated":true}],"references":{"doc://SwAuth/documentation/SwAuth":{"role":"collection","title":"SwAuth","abstract":[{"type":"text","text":"Easily send OAuth 2.0 authorized HTTP requests with async\/await in Swift."}],"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth","kind":"symbol","type":"topic","url":"\/documentation\/swauth"},"doc://SwAuth/documentation/SwAuth/PKCEAuthorizationFlow":{"role":"symbol","title":"PKCEAuthorizationFlow","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"PKCEAuthorizationFlow"}],"abstract":[{"type":"text","text":"The Proof Key for Code Exchange (PKCE) extension to the OAuth 2.0 Authorization Code Grant according to"},{"type":"text","text":" "},{"type":"text","text":"RFC 7636."}],"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/PKCEAuthorizationFlow","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PKCEAuthorizationFlow"}],"url":"\/documentation\/swauth\/pkceauthorizationflow"},"doc://SwAuth/documentation/SwAuth/AuthorizationCodeFlow":{"role":"symbol","title":"AuthorizationCodeFlow","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AuthorizationCodeFlow"}],"abstract":[{"type":"text","text":"The OAuth 2.0 Authorization Code Grant according to RFC 6749\/6750."}],"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/AuthorizationCodeFlow","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AuthorizationCodeFlow"}],"url":"\/documentation\/swauth\/authorizationcodeflow"},"doc://SwAuth/documentation/SwAuth/DeviceAuthorizationFlow":{"role":"symbol","title":"DeviceAuthorizationFlow","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DeviceAuthorizationFlow"}],"abstract":[{"type":"text","text":"The Device Authorization Grant extension to the OAuth 2.0 Authorization Code Grant according to to"},{"type":"text","text":" "},{"type":"text","text":"RFC 8628."}],"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/DeviceAuthorizationFlow","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DeviceAuthorizationFlow"}],"url":"\/documentation\/swauth\/deviceauthorizationflow"},"doc://SwAuth/documentation/SwAuth/Swauthable":{"role":"symbol","title":"Swauthable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Swauthable"}],"abstract":[{"type":"text","text":"All of the authorization flows ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/AuthorizationCodeFlow"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/PKCEAuthorizationFlow"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/DeviceAuthorizationFlow"},{"type":"text","text":") conform to this protocol."}],"identifier":"doc:\/\/SwAuth\/documentation\/SwAuth\/Swauthable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Swauthable"}],"url":"\/documentation\/swauth\/swauthable"},"https://datatracker.ietf.org/doc/html/rfc7636":{"title":"RFC 7636","titleInlineContent":[{"type":"text","text":"RFC 7636"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc7636","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc7636"},"https://github.com/panva/node-oidc-provider":{"title":"here‚Äôs one for Node.js","titleInlineContent":[{"type":"text","text":"here‚Äôs one for Node.js"}],"type":"link","identifier":"https:\/\/github.com\/panva\/node-oidc-provider","url":"https:\/\/github.com\/panva\/node-oidc-provider"}}}